# 2024. è€ƒè¯•çš„æœ€å¤§å›°æ‰°åº¦

- [ðŸ”—é¢˜ç›®é“¾æŽ¥](https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/)

æ»‘åŠ¨åŒºé—´ã€‚

æŠŠé¢˜ç›®è½¬åŒ–ä¸ºï¼Œå¯ä»¥åŒ…å«æœ€å¤škä¸ªç›®æ ‡å­—ç¬¦çš„æœ€é•¿é•¿åº¦ã€‚ç”¨åŒæŒ‡é’ˆè®°å½•åŒºé—´ï¼Œç»Ÿè®¡å…¶å†…éƒ¨ç›®æ ‡å­—ç¬¦çš„æ•°é‡ï¼Œå½“å¤§äºŽkæ—¶å°±ç§»åŠ¨å·¦æŒ‡é’ˆã€‚

åˆ†ä¸¤æ¬¡æ“ä½œï¼Œåˆ†åˆ«ç»Ÿè®¡Tä¸ºç›®æ ‡å­—ç¬¦å’ŒFä¸ºç›®æ ‡å­—ç¬¦çš„å­å­—ç¬¦ä¸²æœ€é•¿é•¿åº¦ã€‚

```kotlin
import kotlin.math.max

/**
 * @author Yananart
 */
class Solution {
    fun maxConsecutiveAnswers(answerKey: String, k: Int): Int {
        return max(replaceMaxSize(answerKey, k, 'T'), replaceMaxSize(answerKey, k, 'F'))
    }

    private fun replaceMaxSize(answerKey: String, maxOps: Int, replaceKey: Char): Int {
        var left = 0
        var now = if (answerKey[0] == replaceKey) 1 else 0
        var ans = 1
        for (right in 1 until answerKey.length) {
            if (answerKey[right] == replaceKey) {
                now++
            }
            if (now > maxOps) {
                while (true) {
                    left++
                    if (answerKey[left - 1] == replaceKey) {
                        break
                    }
                }
                now--
            }
            val length = right - left + 1
            ans = max(ans, length)
        }
        return ans
    }
}
```
