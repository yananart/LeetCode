# 117. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ II

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)

å¯å‚è€ƒ[é¢˜116](0116.populating-next-right-pointers-in-each-node.md)ï¼ŒBFSã€‚

é¦–å…ˆå»ºç«‹ä¸€å±‚çš„å…³ç³»ï¼Œä¸åŒäºä¸Šé¢˜ï¼Œä¸Šé¢˜ä¸­ç”±äºæ˜¯å®Œæ•´çš„äºŒå‰æ ‘ï¼Œè¿™è¾¹ä¸æ˜¯ï¼Œæ‰€ä»¥éœ€è¦åˆ¤æ–­è¿æ¥çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ã€‚

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun connect(root: Node?): Node? {
        if (root == null) {
            return null
        }
        val queue = ArrayDeque<Node>()
        queue.add(root)
        while (queue.isNotEmpty()) {
            val node = queue.removeFirst()
            if (node.left != null && node.right != null) {
                // å·¦å³å­å¥å…¨
                node.left!!.next = node.right
                queue.add(node.left!!)
                queue.add(node.right!!)
                findNextNode(node, node.right!!)
            } else if (node.left != null || node.right != null) {
                // ä»…æœ‰ä¸€ä¸ªå­
                val first = node.left ?: node.right
                queue.add(first!!)
                findNextNode(node, first)
            }
        }
        return root
    }

    private fun findNextNode(father: Node, first: Node) {
        var next = father.next
        while (next != null) {
            if (next.left != null || next.right != null) {
                first.next = next.left ?: next.right
                // æ‰¾åˆ°å°±ä¸ç”¨å†æ‰¾äº†
                break
            }
            next = next.next
        }
    }
}

class Node(var `val`: Int) {
    var left: Node? = null
    var right: Node? = null
    var next: Node? = null
}
```
