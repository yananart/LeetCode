# 322. é›¶é’±å…‘æ¢

- [ðŸ”—é¢˜ç›®é“¾æŽ¥](https://leetcode-cn.com/problems/coin-change/)

åŠ¨æ€è§„åˆ’ã€‚

è®¾`dp[i]`æ˜¯å¯ä»¥å‡‘iå…ƒçš„æœ€å°‘ç¡¬å¸æ•°ï¼Œåˆå§‹æœ‰æ¯ä¸ªå¸ç§çš„`dp[i]=1`ã€‚

ä»Žæœ€å°é‡‘é¢å¼€å§‹ï¼Œå½“å‰é‡‘é¢åŠ ä¸Šä»»æ„ä¸€ä¸ªç¡¬å¸å¯è¾¾ä½ç½®ä¸ºæ–°çš„`dp[j]`ï¼Œå¦‚æžœéœ€è¦çš„ç¡¬å¸å·²ç»å¤§äºŽ`dp[j]`åˆ™æ— éœ€æ›´æ–°ã€‚

æ³¨æ„ï¼Œé¢˜ç›®ä¸­å¯èƒ½è¶…è¿‡intï¼Œé¢˜ç›®ä¸­å¯¹äºŽä¸å¯è¾¾çš„é‡‘é¢éœ€è¦è·³è¿‡ã€‚

```kotlin
import kotlin.math.min

/**
 * @author Yananart
 */
class Solution {
    fun coinChange(coins: IntArray, amount: Int): Int {
        if (amount == 0) return 0
        if (amount in coins) return 1
        coins.sort()
        if (coins[0] > amount) return -1
        val dp = IntArray(amount + 1) { Int.MAX_VALUE }
        for (coin in coins) {
            if (coin <= amount) {
                dp[coin] = 1
            } else {
                break
            }
        }
        val start = coins[0]
        for (now in start until amount) {
            if (dp[now] == Int.MAX_VALUE) {
                // å½“å‰é‡‘é¢ä¸å¯è¾¾ï¼Œçœç•¥
                continue
            }
            for (coin in coins) {
                val next = now.toLong() + coin
                if (next <= amount) {
                    // è®¡ç®—ä¸‹ä¸€ä¸ªé‡‘é¢çš„æœ€å°‘
                    dp[next.toInt()] = min(dp[next.toInt()], dp[now] + 1)
                } else {
                    break
                }
            }
        }
        return if (dp[amount] == Int.MAX_VALUE) -1 else dp[amount]
    }
}
```
