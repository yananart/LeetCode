# 393. UTF-8 ç¼–ç éªŒè¯

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/utf-8-validation/)

ç†Ÿæ‚‰ä½è¿ç®—å³å¯ã€‚ç›¸å…³åˆ¤æ–­æ¡ä»¶åœ¨ä»£ç ä¸­è¿›è¡Œäº†è¯´æ˜ã€‚

**æ³¨æ„**ï¼šç”±äºå¤šå­—èŠ‚ä½†å­—ç¬¦ä¸å¯èƒ½è¶…è¿‡4å­—èŠ‚ï¼Œå¦‚æœè®¡ç®—å‘ç°é¦–ä½æ˜¯é•¿åº¦ä½ä¸”è¡¨ç¤ºä½†é•¿åº¦>=4ï¼Œä¹Ÿæ˜¯é”™è¯¯çš„ã€‚

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun validUtf8(data: IntArray): Boolean {
        // åç»­éœ€è¦çš„æ•°æ®å­—èŠ‚æ•° 0å°±ä»£è¡¨æ˜¯éœ€è¦èµ·å§‹ä½äº† æ•°å­—ä»£è¡¨éœ€è¦åº¦æ•°æ®å­—èŠ‚æ•°
        var shouldData: Byte = 0
        for (b in data) {
            val type = getByteType(b)
            if (shouldData == 0.toByte()) {
                // éœ€è¦èµ·å§‹ä½
                if (type == (-1).toByte()) {
                    // ä½†å½“å‰å´æ˜¯æ•°æ® é”™è¯¯
                    return false
                }
                if (type >= 4) {
                    // ä¸å¯èƒ½å¤§äºå››ä¸ªå­—èŠ‚
                    return false
                }
                // ä¸‹ä¸ªä½ç½®åº”è¯¥æ˜¯
                shouldData = type
            } else {
                // éœ€è¦æ•°æ®ä½
                if (type >= 0) {
                    // ä½†å½“å‰å´æ˜¯èµ·å§‹ä½ é”™è¯¯
                    return false
                }
                shouldData--
            }
        }
        // å½“å‰å·²ç»ç»“æŸäº†ï¼Œæœ€ååº”è¯¥æ˜¯0äº†
        return shouldData == 0.toByte()
    }

    /**
     * åˆ¤æ–­å­—èŠ‚ç±»å‹
     *
     * @param b å­—èŠ‚
     * @return æ˜¯å¤šå­—èŠ‚çš„èµ·å§‹çš„è¯è¿”å›å¯¹åº”å­—èŠ‚æ•°ï¼Œæ˜¯å•å­—èŠ‚å­—ç¬¦è¿”å›0ï¼Œæ˜¯å¤šå­—èŠ‚åç»­å­—ç¬¦è¿”å›-1
     */
    private fun getByteType(b: Int): Byte {
        if (b.and(0b11000000) == 0b10000000) {
            // é¦–ä½æ˜¯10çš„
            return -1
        }
        if (b.and(0b10000000) == 0b00000000) {
            // é¦–ä½æ˜¯0çš„
            return 0
        }
        var res: Byte = 0
        var bi = 0b01000000
        while (b.and(bi) != 0) {
            res++
            // ä½å³ç§»
            bi = bi.shr(1)
        }
        return res
    }
}
```
