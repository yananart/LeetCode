# 23. åˆå¹¶Kä¸ªå‡åºé“¾è¡¨

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/merge-k-sorted-lists/)

## å½’å¹¶

å¾ªç¯å°†ä¸¤ä¸ªé“¾è¡¨å½’å¹¶ï¼Œå½’å¹¶å¯å‚è€ƒ[é¢˜21](0021.merge-two-sorted-lists.md)ã€‚æœ¬é¢˜æ¢äº†ç§å†™æ³•ã€‚

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun mergeKLists(lists: Array<ListNode?>): ListNode? {
        if (lists.isEmpty()) {
            return null
        }
        var res = lists[0]
        for (index in 1 until lists.size) {
            res = merge2List(res, lists[index])
        }
        return res
    }

    private fun merge2List(a: ListNode?, b: ListNode?): ListNode? {
        if (a == null) {
            return b
        } else if (b == null) {
            return a
        }
        if (a.`val` > b.`val`) {
            // aé“¾è¡¨é¦–ä½è¦æ¯”bçš„å°
            return merge2List(b, a)
        }
        var aNow = a
        var bNow = b
        while (bNow != null) {
            if (aNow!!.next == null) {
                aNow.next = bNow
                bNow = null
            } else {
                if (aNow.next!!.`val` < bNow.`val`) {
                    // açš„nextæ¯”bå°ï¼Œaç§»åŠ¨åˆ°next
                    aNow = aNow.next
                } else {
                    // açš„nextæ¯”å½“å‰çš„bå¤§
                    // è®°å½•açš„next
                    val temp = aNow.next
                    // açš„nextè½¬æ¢ä¸ºb
                    aNow.next = bNow
                    // bè½¬æ¢ä¸ºbçš„next
                    bNow = bNow.next
                    // aè½¬æ¢ä¸ºaçš„next
                    aNow = aNow.next
                    // açš„nextè¿˜åŸ
                    aNow!!.next = temp
                }
            }
        }
        return a
    }
}

class ListNode(var `val`: Int) {
    var next: ListNode? = null
}
```

## ä¼˜å…ˆé˜Ÿåˆ—

æˆ‘ä»¬åŒæ—¶æ‹¿åˆ°kä¸ªé“¾è¡¨æ—¶ï¼Œå…¶å®æœ¬èº«å°±æ˜¯æ¯æ¬¡å–kä¸ªé¡¶éƒ¨å…ƒç´ çš„æœ€å°å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æ¯æ¬¡å–å‡ºé“¾è¡¨å¤´éƒ¨å…ƒç´ æ”¾å…¥ä¼˜å…ˆé˜Ÿåˆ—ï¼Œç„¶åä»ä¼˜å…ˆé˜Ÿåˆ—ä¸­å–å‡ºæœ€å°çš„ã€‚

```kotlin
import java.util.*

/**
 * @author Yananart
 */
class Solution {
    fun mergeKLists(lists: Array<ListNode?>): ListNode? {
        if (lists.isEmpty()) {
            return null
        }
        val queue: PriorityQueue<Status> = PriorityQueue<Status>()
        for (node in lists) {
            if (node != null) {
                queue.offer(Status(node.`val`, node))
            }
        }
        val res = ListNode(-1)
        var tail: ListNode? = res
        while (!queue.isEmpty()) {
            val now = queue.poll()
            tail!!.next = now.node
            tail = tail.next
            if (now.node.next != null) {
                queue.offer(Status(now.node.next!!.`val`, now.node.next!!))
            }
        }
        return res.next
    }
}

class Status(var `val`: Int, var node: ListNode) : Comparable<Status?> {
    override fun compareTo(other: Status?): Int {
        return `val` - other!!.`val`
    }
}

class ListNode(var `val`: Int) {
    var next: ListNode? = null
}
```
