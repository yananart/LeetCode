# 673. æœ€é•¿é€’å¢å­åºåˆ—çš„ä¸ªæ•°

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence/)

åŠ¨æ€è§„åˆ’ã€‚

å‚è€ƒ[é¢˜300](0300.longest-increasing-subsequence.md)

ä¸åŒä¸å‰é¢˜ï¼Œæˆ‘ä»¬åœ¨å¾—å‡ºæ¯ä¸ªdp[i]æ—¶ï¼Œè¿˜éœ€è¦çŸ¥é“å¯¹åº”çš„è·¯å¾„æ•°ã€‚æˆ‘ä»¬å¯ä»¥é€šè¿‡ç»Ÿè®¡å…¶å‰é¢ç¬¦åˆè¦æ±‚ä¸”+1ç­‰äºå…¶è‡ªèº«çš„ä½ç½®çš„è·¯å¾„æ•°å’Œã€‚

å³`dp[i]=dp[j]+1`ï¼Œå¾—åˆ°æ‰€æœ‰ç¬¦åˆè¦æ±‚çš„jï¼Œ`dpCount[i]=sum(dpCount[j])`ã€‚

```kotlin
import kotlin.math.max

/**
 * @author Yananart
 */
class Solution {
    fun findNumberOfLIS(nums: IntArray): Int {
        val dp = IntArray(nums.size) { 1 }
        val dpCount = IntArray(nums.size)
        dpCount[0] = 1
        var max = 1
        for (i in 1 until nums.size) {
            var count = 0
            for (j in 0 until i) {
                if (nums[j] < nums[i]) {
                    if (dp[i] == dp[j] + 1) {
                        count += dpCount[j]
                    } else if (dp[i] < dp[j] + 1) {
                        dp[i] = dp[j] + 1
                        count = dpCount[j]
                    }
                }
            }
            if (dp[i] == 1) {
                count = 1
            }
            dpCount[i] = count
            max = max(dp[i], max)
        }
        var total = 0
        for (i in dp.indices) {
            if (dp[i] == max) {
                total += dpCount[i]
            }
        }
        return total
    }
}
```
