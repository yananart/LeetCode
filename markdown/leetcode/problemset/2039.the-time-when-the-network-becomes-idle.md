# 2039. ç½‘ç»œç©ºé—²çš„æ—¶åˆ»

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/)

## å»ºå›¾+BFS

æˆ‘ä»¬å…ˆæŒ‰é¢˜ç›®ä¸­æä¾›çš„è¾¹ï¼Œå»ºç«‹æˆ‘ä»¬è‡ªå·±çš„å…³è”å…³ç³»ï¼Œæˆä¸ºä¸€å¼ å›¾ã€‚

ç„¶åä»0èŠ‚ç‚¹å¼€å§‹ï¼Œé€šè¿‡BFSè®¡ç®—å‡ºæ¯ä¸€ä¸ªèŠ‚ç‚¹åˆ°0èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»`distance`ã€‚

éå†æ¯ä¸€ä¸ªèŠ‚ç‚¹ï¼Œè®¡ç®—ä»…è€ƒè™‘è¯¥èŠ‚ç‚¹è‡ªèº«å…¶è¾¾åˆ°ç©ºé—²çš„æ—¶é—´ã€‚

- å…ˆè®¡ç®—å…¶ä¸€æ¬¡é€šä¿¡çš„æ—¶é—´æ˜¯ä¸0èŠ‚ç‚¹çš„æœ€çŸ­è·ç¦»ä¹˜2`distance*2`ï¼›
- å…¶å®Œæˆç¬¬ä¸€æ¬¡é€šä¿¡é—´çš„æ—¶é—´æ˜¯`[1,distance*2)`ï¼Œå…¶ä¸­é—´å¯ä»¥å‘ç”Ÿä¿¡å·çš„æ¬¡æ•°æ˜¯`(distance*2-1)/patience`ï¼›
- å…¶æœ€åä¸€æ¬¡å‘ç”Ÿä¿¡å·çš„æ—¶é—´æ˜¯`(distance*2-1)/patience`(å‰é¢è¦å–æ•´)å†`*patience`ï¼ŒåŠ ä¸Šä¸€æ¬¡é€šä¿¡æ—¶é—´æ˜¯å…¶å®Œæˆé€šä¿¡çš„æ—¶é—´ï¼›
- å†å®Œæˆé€šä¿¡çš„æ—¶é—´åŸºç¡€ä¸Š+1ï¼Œå°±æ˜¯å…¶è¾¾åˆ°ç©ºé—²çš„æ—¶é—´

æŒ‰ä¸Šè¿°æ­¥éª¤ç®—å‡ºæ¯ä¸ªèŠ‚ç‚¹çš„æ—¶é—´ï¼Œå–æœ€å¤§çš„æ—¶é—´è¿”å›ã€‚

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun networkBecomesIdle(edges: Array<IntArray>, patience: IntArray): Int {
        // é‡æ–°ç»˜åˆ¶ä¸€å¼ å›¾
        val relation = Array(patience.size) { HashSet<Int>() }
        for (edge in edges) {
            relation[edge[0]].add(edge[1])
            relation[edge[1]].add(edge[0])
        }
        // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹åˆ°0çš„è·ç¦»
        val distance = IntArray(patience.size) { if (it == 0) 0 else -1 }
        // bfs
        val queue = ArrayDeque<Int>()
        val nextQueue = ArrayDeque(relation[0])
        var deep = 0
        while (queue.isNotEmpty() || nextQueue.isNotEmpty()) {
            if (queue.isEmpty()) {
                queue.addAll(nextQueue)
                nextQueue.clear()
                deep++
            }
            val node = queue.removeFirst()
            if (distance[node] == -1) {
                distance[node] = deep
                nextQueue.addAll(relation[node])
            }
        }
        // è®¡ç®—æ¯ä¸ªèŠ‚ç‚¹åˆ°ç©ºé—²åˆ°æœ€å¤§æ—¶é—´
        var maxTime = 0
        for (node in 1 until distance.size) {
            // å‘ä¿¡å·åˆ°æ¬¡æ•°
            val times = 1 + (distance[node] * 2 - 1) / patience[node]
            // è¯¥èŠ‚ç‚¹åˆ°ç©ºé—²çš„æ—¶é—´
            val time = (times - 1) * patience[node] + distance[node] * 2 + 1
            if (time > maxTime) {
                maxTime = time
            }
        }
        return maxTime
    }
}
```
