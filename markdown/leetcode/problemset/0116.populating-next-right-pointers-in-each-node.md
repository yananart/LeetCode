# 116. å¡«å……æ¯ä¸ªèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªå³ä¾§èŠ‚ç‚¹æŒ‡é’ˆ

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)

## é˜Ÿåˆ—è®°å½•+æ ‘éå†

éå†æ ‘ï¼Œè®°å½•éå†çš„æ·±åº¦ï¼Œåœ¨åŒæ·±åº¦çš„èŠ‚ç‚¹æ”¾å…¥ä¸€ä¸ªé˜Ÿåˆ—ä¸­ã€‚å®Œæˆåå°†é˜Ÿåˆ—ä¸­çš„èŠ‚ç‚¹æŒ‰é¡ºåºè¿æ¥ã€‚`BFS`æˆ–`DFS`å‡å¯ã€‚

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun connect(root: Node?): Node? {
        if (root == null) {
            return null
        }
        val deepQueue = ArrayList<ArrayList<Node>>()
        scanNode(root, 0, deepQueue)
        for (queue in deepQueue) {
            // è¿æ¥ä¸€ä¸ªé˜Ÿåˆ—ä¸Šçš„èŠ‚ç‚¹
            for (index in 0 until queue.size - 1) {
                queue[index].next = queue[index + 1]
            }
        }
        return root
    }

    private fun scanNode(node: Node, deep: Int, deepQueue: ArrayList<ArrayList<Node>>) {
        if (deepQueue.size <= deep) {
            deepQueue.add(ArrayList())
        }
        // å¯¹åº”æ·±åº¦çš„é˜Ÿåˆ—ä¸Šè®°å½•è¿™ä¸ªèŠ‚ç‚¹
        deepQueue[deep].add(node)
        if (node.left != null && node.right != null) {
            // å®Œç¾äºŒå‰
            scanNode(node.left!!, deep + 1, deepQueue)
            scanNode(node.right!!, deep + 1, deepQueue)
        }
    }
}

class Node(var `val`: Int) {
    var left: Node? = null
    var right: Node? = null
    var next: Node? = null
}
```

## ä½¿ç”¨å·²å»ºç«‹çš„nextå…³ç³»

åœ¨æˆ‘ä»¬éå†åˆ°æ ‘çš„ä¸€ä¸ªèŠ‚ç‚¹æ—¶ï¼Œå‡å¦‚å®ƒæœ‰å­èŠ‚ç‚¹ï¼Œé‚£ä¹ˆå®ƒçš„å·¦å­èŠ‚ç‚¹çš„next=å³å­èŠ‚ç‚¹ï¼Œè€Œå³å­èŠ‚ç‚¹çš„next=å½“å‰èŠ‚ç‚¹nextèŠ‚ç‚¹çš„å·¦å­èŠ‚ç‚¹ã€‚

é‚£ä¹ˆï¼Œæˆ‘ä»¬åœ¨å»ºç«‹ç¬¬deepå±‚çš„nextå…³ç³»æ—¶ï¼Œåªè¦ä¿è¯ä¸Šå±‚çš„nextå…³ç³»å·²ç»è¢«å»ºç«‹ï¼Œé‚£ä¹ˆæœ¬å±‚çš„nextå…³ç³»å°±å¯ä»¥é€’æ¨äº†ã€‚

å¯ä½¿ç”¨BFSå®ç°è¯¥è¿‡ç¨‹ã€‚

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun connect(root: Node?): Node? {
        if (root == null) {
            return null
        }
        val queue = ArrayDeque<Node>()
        queue.add(root)
        while (queue.isNotEmpty()) {
            val node = queue.removeFirst()
            if (node.left != null && node.right != null) {
                node.left!!.next = node.right
                if (node.next != null) {
                    node.right!!.next = node.next!!.left
                }
                queue.add(node.left!!)
                queue.add(node.right!!)
            }
        }
        return root
    }
}

class Node(var `val`: Int) {
    var left: Node? = null
    var right: Node? = null
    var next: Node? = null
}
```
