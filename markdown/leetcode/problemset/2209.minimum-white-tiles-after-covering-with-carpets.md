# 2209. ç”¨åœ°æ¯¯è¦†ç›–åçš„æœ€å°‘ç™½è‰²ç –å—

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/minimum-white-tiles-after-covering-with-carpets/)

## åŠ¨æ€è§„åˆ’

æˆ‘ä»¬æŠŠé—®é¢˜ä¸­çš„ç›®æ ‡è½¬åŒ–ä¸ºä¸€ä¸ªå‡½æ•°ï¼š`dp[i][j]`ï¼Œè¡¨ç¤ºç”¨`i`æ¡åœ°æ¯¯è¦†ç›–å‰`j`å—æ¿ç –æ—¶ï¼Œæ²¡è¢«è¦†ç›–çš„ç™½è‰²ç –å—çš„æœ€å°‘æ•°é‡ã€‚

æ¨å¯¼ä»¥ä¸‹çŠ¶æ€è½¬ç§»æ–¹ç¨‹ï¼š

- `i==0`æ—¶ï¼Œæ²¡æœ‰é“ºåœ°æ¯¯ï¼Œ`dp[0][j]`å°±æ˜¯å‰jå—ç –ä¸­ç™½è‰²ç –å—çš„æ€»é‡ï¼›
- `i!=0`æ—¶ï¼Œ`dp[i][j]=min(dp[i][j-1]+floor[j]=='1', dp[i-1][j-carpetLen])`ï¼Œä»£è¡¨
    - `dp[i][j-1]+floor[j]=='1'`è¡¨ç¤ºå‰`j-1`å—åœ°æ¿ç”¨äº†`i`æ¡åœ°æ¯¯ï¼Œå‰©ä½™æœ€å°‘çš„ç™½è‰²ç –å—ï¼ŒåŠ ä¸Šç¬¬`j`å—åœ°æ¿æ˜¯å¦ä¸ºç™½è‰²ç –å—ï¼ˆå³ç¬¬`j`ä¸ªä½ç½®æ²¡æœ‰åœ°æ¯¯ï¼‰;
    - `dp[i-1][j-carpetLen]`è¡¨ç¤ºåœ¨ä¸‹æ ‡`j`è¿™é‡Œç”¨äº†åœ°æ¯¯(å³è¾¹å¯¹å…¶)ï¼Œé‚£ä¹ˆ`dp[i][j]`å°±å’Œå‰`j-carpetLen`å—åœ°æ¿ä¸­ç”¨äº†`i-1`æ¡åœ°æ¯¯å‰©ä½™çš„ç™½è‰²ç –å—æ•°ç›®ä¸€è‡´ï¼ˆå³ç¬¬`j`ä¸ªä½ç½®ç”¨äº†åœ°æ¯¯ï¼‰

```kotlin
import kotlin.math.min

/**
 * @author Yananart
 */
class Solution {
    fun minimumWhiteTiles(floorStr: String, numCarpets: Int, carpetLen: Int): Int {
        val length = floorStr.length
        val floor = ByteArray(length) { floorStr[it].toString().toByte() }
        val dp = Array(numCarpets + 1) { IntArray(length) }
        // åˆå§‹åŒ–æ²¡æœ‰åœ°æ¯¯çš„èµ·å§‹çŠ¶æ€
        dp[0][0] = floorStr[0].toString().toInt()
        for (i in 1 until length) {
            dp[0][i] = dp[0][i - 1] + floor[i]
        }
        // çŠ¶æ€è½¬ç§»
        for (i in 1..numCarpets) {
            for (j in carpetLen until length) {
                dp[i][j] = min(dp[i][j - 1] + floor[j], dp[i - 1][j - carpetLen])
            }
        }
        return dp[numCarpets][length - 1]
    }
}
```
