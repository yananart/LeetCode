# 310. æœ€å°é«˜åº¦æ ‘

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/minimum-height-trees/)

å¹¿åº¦ä¼˜å…ˆæœç´¢+å‡å°å›¾ã€‚

å¦‚æœæ¯ä¸ªèŠ‚ç‚¹éƒ½è¿›è¡Œä¸€éæœç´¢å°†ä¼šè¶…æ—¶ã€‚

æˆ‘ä»¬æ€è€ƒï¼Œä¼šå‘ç°æœ€å°æ·±åº¦æ ‘ä¸€å®šæ˜¯åœ¨ä¸­é—´çš„èŠ‚ç‚¹æœ€ä¸ºæ ¹èŠ‚ç‚¹çš„ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥æœ‰ä¸€ä¸ªæƒ³æ³•ï¼Œä»æ ‘çš„å¤–é¢èŠ‚ç‚¹ä¸€å±‚ä¸€å±‚å¾€é‡Œåˆ ï¼Œåˆ åˆ°æœ€åä¸€å±‚çš„èŠ‚ç‚¹å°±æ˜¯ç¦»æœ€å­èŠ‚ç‚¹æœ€è¿œçš„èŠ‚ç‚¹ï¼Œå–å…¶ä½œä¸ºæ ¹èŠ‚ç‚¹æ ‘æ·±åº¦æœ€å°ã€‚

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun findMinHeightTrees(n: Int, edges: Array<IntArray>): List<Int> {
        if (n == 1) {
            return listOf(0)
        }
        val relation = Array(n) { ArrayList<Int>() }
        // è®°å½•èŠ‚ç‚¹çš„ä½¿ç”¨æ¬¡æ•°
        val usage = IntArray(n) { 0 }
        for (edge in edges) {
            relation[edge[0]].add(edge[1])
            relation[edge[1]].add(edge[0])
            usage[edge[0]]++
            usage[edge[1]]++
        }
        var res = ArrayList<Int>()

        val queue = ArrayDeque<Int>()
        for (node in usage.indices) {
            if (usage[node] == 1) {
                // ä½¿ç”¨æ¬¡æ•°ä¸ºä¸€æ¬¡çš„å°±æ˜¯æœ€å­çš„å¶å­èŠ‚ç‚¹
                queue.add(node)
            }
        }

        while (queue.isNotEmpty()) {
            res = ArrayList()
            for (index in queue.indices) {
                val now = queue.removeFirst()
                res.add(now)
                for (next in relation[now]) {
                    usage[next]--
                    if (usage[next] == 1) {
                        queue.add(next)
                    }
                }
            }
        }

        return res
    }
}
```
