# 5. æœ€é•¿å›æ–‡å­ä¸²

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/longest-palindromic-substring/)

## åŠ¨æ€è§„åˆ’

ç”¨ç©ºé—´æ¢æ—¶é—´ï¼Œå»ºç«‹ä¸€ä¸ªäºŒç»´æ•°ç»„`bool[][] dp`ï¼Œå…¶ä¸­`dp[i][j]`ä»£è¡¨å­—ç¬¦ä¸²ä¸­ç¬¬`i`ä½åˆ°ç¬¬`j`ä½æ˜¯å¦ä¸ºå›æ–‡ä¸²ã€‚

åŸºäºä¸Šè¿°è§„åˆ™ï¼Œæˆ‘ä»¬å¯ä»¥å¾—å‡ºå¦‚æœ`dp[left][right]==ture`ä¸”`s[left-1]==s[right+1]`ï¼Œåˆ™`left-1`åˆ°`right+1`ä¹Ÿæ˜¯å›æ–‡å­—ç¬¦ä¸²ã€‚

æ•°ç»„åˆå§‹åŒ–æ—¶`left`==`right`ä½ç½®ä¸º`true`ï¼Œéå†ä¸­å¦‚æœ`s[left]==s[left+1]`ï¼Œåˆ™ä¹Ÿè®¾ç½®`dp[left][left+1]=true`

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun longestPalindrome(s: String): String {
        if (s.length < 2) {
            return s
        }

        var maxStart = 0
        var maxEnd = 0
        var maxLength = 1

        // åŠ¨æ€è§„åˆ’å­˜å‚¨æ•°ç»„ i==jä½ç½®åˆå§‹åŒ–ä¸ºtrue
        val dpMap = Array(s.length) { i -> Array(s.length) { j -> i == j } }
        for (right in s.indices) {
            for (left in 0 until right) {
                if (s[right] == s[left] && (right - left == 1 || dpMap[left + 1][right - 1])) {
                    // å·¦å³ä½ç½®ç›¸åŒï¼Œå½“ä¸­é—´æ˜¯å›æ–‡æˆ–å·¦å³ä½ç½®åªç›¸å·®1æ—¶ï¼ŒåŠ ä¸Šå·¦å³ä½ç½®çš„å­ä¸²ä¹Ÿæ˜¯å›æ–‡
                    dpMap[left][right] = true
                    if (right - left + 1 > maxLength) {
                        maxLength = right - left + 1
                        maxStart = left
                        maxEnd = right
                    }
                }
            }
        }

        return s.substring(maxStart, maxEnd + 1)
    }
}
```

## ä¼˜åŒ–è§£æ³• è´ªå¿ƒ

ä¸Šé¢çš„åŠ¨æ€è§„åˆ’æ—¶é—´å¤æ‚åº¦ä¸º`O(n^2)`ï¼Œå…¶å®ä¸­é—´æœ‰å¾ˆå¤šåˆ¤æ–­å¾ˆæµªè´¹ã€‚ä»¥ä¸‹é‡‡ç”¨è´ªå¿ƒåšæ³•ã€‚

æˆ‘ä»¬ç°åœ¨éå†å­—ç¬¦ä¸²ï¼Œä»å½“å‰å­—ç¬¦ä½å¾€ååˆ¤æ–­ï¼Œå…ˆæ‰¾åˆ°æ‰€æœ‰ä¸€æ ·çš„å­—ç¬¦ï¼Œç„¶åä»¥è¿™ä¸ªå­ä¸²(å…¨æ˜¯ä¸€æ ·çš„å­—ç¬¦)ï¼Œå·¦å³ä¸¤è¾¹æŸ¥æ˜¯ä¸æ˜¯ç›¸åŒçš„ï¼Œä¸€ç›´æ‰¾åˆ°æœ€é•¿çš„å­ä¸²ã€‚

ä¸‹æ¬¡ä»ä¸Šæ¬¡æŸ¥è¯¢åˆ°çš„å­—ç¬¦åçš„ç¬¬ä¸€ä¸ªä¸åŒå­—ç¬¦å¼€å§‹ï¼Œå†ä¸€æ¬¡æ“ä½œã€‚

æŒ‰ä»¥ä¸Šè§„åˆ™ï¼Œæ—¶é—´å¤æ‚åº¦æœ€å°‘æ˜¯`O(n)`æ­£å¸¸åº”è¯¥æ˜¯`O(n*log(n))`ï¼Œä¸ä¼šåˆ°è¾¾`O(n^2)`

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun longestPalindrome(s: String): String {
        if (s.isEmpty()) {
            return ""
        }
        // ä¿å­˜èµ·å§‹ä½ç½®ï¼Œæµ‹è¯•äº†ç”¨æ•°ç»„ä¼¼ä¹èƒ½æ¯”å…¨å±€å˜é‡ç¨å¿«ä¸€ç‚¹
        val range = IntArray(2)
        val str = s.toCharArray()
        var i = 0
        while (i < s.length) {
            // æŠŠå›æ–‡çœ‹æˆä¸­é—´çš„éƒ¨åˆ†å…¨æ˜¯åŒä¸€å­—ç¬¦ï¼Œå·¦å³éƒ¨åˆ†ç›¸å¯¹ç§°
            // æ‰¾åˆ°ä¸‹ä¸€ä¸ªä¸å½“å‰å­—ç¬¦ä¸åŒçš„å­—ç¬¦
            i = findLongest(str, i, range)
            i++
        }
        return s.substring(range[0], range[1] + 1)
    }

    /**
     * æ‰¾åˆ°æœ€é•¿å­ä¸²
     */
    private fun findLongest(str: CharArray, low: Int, range: IntArray): Int {
        // æŸ¥æ‰¾ä¸­é—´éƒ¨åˆ†
        var low = low
        var high = low
        while (high < str.size - 1 && str[high + 1] == str[low]) {
            high++
        }
        // å®šä½ä¸­é—´éƒ¨åˆ†çš„æœ€åä¸€ä¸ªå­—ç¬¦
        val next = high
        // ä»ä¸­é—´å‘å·¦å³æ‰©æ•£
        while (low > 0 && high < str.size - 1 && str[low - 1] == str[high + 1]) {
            low--
            high++
        }
        // è®°å½•æœ€å¤§é•¿åº¦
        if (high - low > range[1] - range[0]) {
            range[0] = low
            range[1] = high
        }
        return next
    }
}
```