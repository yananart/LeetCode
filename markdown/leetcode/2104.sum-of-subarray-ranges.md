# 2104. å­æ•°ç»„èŒƒå›´å’Œ

- [ğŸ”—é¢˜ç›®é“¾æ¥](https://leetcode-cn.com/problems/sum-of-subarray-ranges/)

## æš´åŠ›è§£æ³•

åŒé‡forå¾ªç¯ï¼Œéå†æ‰€æœ‰è¿ç»­çš„å­æ•°ç»„ï¼Œè®°å½•æ¯æ¬¡çš„æœ€å¤§æœ€å°å€¼ï¼Œè®¡ç®—åç›¸åŠ ã€‚æ—¶é—´å¤æ‚åº¦`O(n^2)`ã€‚

```kotlin
/**
 * @author Yananart
 */
class Solution {
    fun subArrayRanges(nums: IntArray): Long {
        var res = 0L
        for (left in 0 until nums.size - 1) {
            var max = nums[left]
            var min = max
            for (right in left + 1 until nums.size) {
                max = max.coerceAtLeast(nums[right])
                min = min.coerceAtMost(nums[right])
                res += (max - min)
            }
        }
        return res
    }
}
```

## å•è°ƒæ ˆ

ä¸»è¦å°±æ˜¯ç¡®å®šæ¯ä¸€ä¸ªæ•°ä½œä¸º**æœ€å¤§**æˆ–**æœ€å°**çš„ä½œç”¨**åŒºé—´èŒƒå›´**ã€‚

ä»¥ï¼š`[2,1,2,âˆ’1,3]`ä¸ºä¾‹è¿›è¡Œè¯´æ˜:

- å½“1ä½œä¸ºæœ€å°å€¼çš„ä½œç”¨çš„åŒºé—´èŒƒå›´ä¸º:`(âˆ’1,1]+[1,3)`
  
  æ‰€ä»¥èƒ½å¤Ÿç»„æˆçš„å­æ•°ç»„çš„ä¸ªæ•°ä¸ºï¼š`n=(1-(-1))*(3-1)=4`
  
  ä¸ºï¼š`[2,1],[1],[1,2],[2,1,2]`
  
  æ‰€ä»¥è¿™ä¸ª 1 ä½œä¸º æœ€å°å€¼ å¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯`-(n*1)`

- å½“2(ä½ç½®2ä¸Šçš„)æœ€ä¸ºæœ€å¤§å€¼çš„ä½œç”¨çš„åŒºé—´èŒƒå›´ä¸º:`(0,2]+[2,4)`
  
  æ‰€ä»¥èƒ½å¤Ÿç»„æˆçš„å­æ•°ç»„çš„ä¸ªæ•°ä¸ºï¼š`n=(2âˆ’0)âˆ—(4âˆ’2)=4`
  
  ä¸ºï¼š`[1,2],[2],[2,âˆ’1],[1,2,âˆ’1]`
  
  æ‰€ä»¥è¿™ä¸ª2ä½œä¸ºæœ€å¤§å€¼å¯¹ç­”æ¡ˆçš„è´¡çŒ®å°±æ˜¯`+(nâˆ—2)`

è¯¥è¿‡ç¨‹å¯ä»¥ç”¨**å•è°ƒæ ˆ**æ¨¡æ‹Ÿï¼Œéœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœå‡ºç°äº†è¿ç»­çš„ç›¸åŒçš„æ•°å­—ï¼Œæˆ‘ä»¬åœ¨é€»è¾‘ä¸Šè®¤ä¸ºæ•°ç»„ä¸­åä¸€ä½æ¯”å‰ä¸€ä½çš„å¤§ã€‚

ä¸‹é¢ä¸¤ç§å†™æ³•é€»è¾‘æ˜¯ä¸€æ ·çš„ã€‚

```kotlin
import java.util.Stack

/**
 * @author Yananart
 */
class Solution {
    fun subArrayRanges(nums: IntArray): Long {
        // å››æ¬¡æ ˆ
        val minStack = Stack<Int>()
        val maxStack = Stack<Int>()
        // iå…ƒç´ å·¦ä¾§æ¯”ä¹‹å°çš„ä½ç½®
        val leftMax = Array(nums.size) { it }
        // iå…ƒç´ å·¦ä¾§æ¯”ä¹‹å¤§çš„ä½ç½®
        val leftMin = Array(nums.size) { it }

        for (index in nums.indices) {
            val now = nums[index]
            while (!minStack.isEmpty() && nums[minStack.peek()] > now) {
                minStack.pop()
            }
            leftMin[index] = if (minStack.isEmpty()) -1 else minStack.peek()
            minStack.push(index)

            // å¦‚æœ nums[maxStack.peek()] == nums[index], é‚£ä¹ˆæ ¹æ®å®šä¹‰ï¼Œ
            // nums[maxStack.peek()] é€»è¾‘ä¸Šå°äº nums[index]ï¼Œå› ä¸º maxStack.peek() < i
            while (!maxStack.isEmpty() && nums[maxStack.peek()] <= now) {
                maxStack.pop()
            }
            leftMax[index] = if (maxStack.isEmpty()) -1 else maxStack.peek()
            maxStack.push(index)
        }
        // iå…ƒç´ å³ä¾§æ¯”ä¹‹å°çš„ä½ç½®
        val rightMin = Array(nums.size) { it }
        // iå…ƒç´ å³ä¾§æ¯”ä¹‹å¤§çš„ä½ç½®
        val rightMax = Array(nums.size) { it }

        minStack.clear()
        maxStack.clear()

        for (index in nums.size - 1 downTo 0) {
            val now = nums[index]
            // å¦‚æœ nums[minStack.peek()] == nums[index], é‚£ä¹ˆæ ¹æ®å®šä¹‰ï¼Œ
            // nums[minStack.peek()] é€»è¾‘ä¸Šå¤§äº nums[index]ï¼Œå› ä¸º minStack.peek() > i
            while (!minStack.isEmpty() && nums[minStack.peek()] >= now) {
                minStack.pop()
            }
            rightMin[index] = if (minStack.isEmpty()) nums.size else minStack.peek()
            minStack.push(index)

            while (!maxStack.isEmpty() && nums[maxStack.peek()] < now) {
                maxStack.pop()
            }
            rightMax[index] = if (maxStack.isEmpty()) nums.size else maxStack.peek()
            maxStack.push(index)
        }
        // ç»“æœ
        var res = 0L
        for (index in nums.indices) {
            // å¤§å€¼ç›¸åŠ 
            res += (rightMax[index] - index).toLong() * (index - leftMax[index]).toLong() * nums[index].toLong()
            // å°å€¼ç›¸å‡
            res -= (rightMin[index] - index).toLong() * (index - leftMin[index]).toLong() * nums[index].toLong()
        }
        return res
    }
}
```

```kotlin
import java.util.Stack

/**
 * @author Yananart
 */
class Solution {
    fun subArrayRanges(nums: IntArray): Long {
        // å››æ¬¡æ ˆ
        val minStack = Stack<Int>()
        val maxStack = Stack<Int>()
        // iå…ƒç´ å·¦ä¾§æ¯”ä¹‹å°çš„ä½ç½®
        val leftMax = Array(nums.size) { it }
        // iå…ƒç´ å·¦ä¾§æ¯”ä¹‹å¤§çš„ä½ç½®
        val leftMin = Array(nums.size) { it }

        minStack.push(-1)
        maxStack.push(-1)

        for (index in nums.indices) {
            val now = nums[index]
            while (true) {
                val top = minStack.peek()
                if (minStack.size > 1 && nums[top] > now) {
                    minStack.pop()
                } else {
                    minStack.push(index)
                    leftMin[index] = top
                    break
                }
            }
            while (true) {
                val top = maxStack.peek()
                if (maxStack.size > 1 && nums[top] <= now) {
                    maxStack.pop()
                } else {
                    maxStack.push(index)
                    leftMax[index] = top
                    break
                }
            }
        }
        // iå…ƒç´ å³ä¾§æ¯”ä¹‹å°çš„ä½ç½®
        val rightMin = Array(nums.size) { it }
        // iå…ƒç´ å³ä¾§æ¯”ä¹‹å¤§çš„ä½ç½®
        val rightMax = Array(nums.size) { it }

        minStack.clear()
        maxStack.clear()
        minStack.push(nums.size)
        maxStack.push(nums.size)

        for (index in nums.size - 1 downTo 0) {
            val now = nums[index]
            while (true) {
                val top = minStack.peek()
                if (minStack.size > 1 && nums[top] >= now) {
                    minStack.pop()
                } else {
                    minStack.push(index)
                    rightMin[index] = top
                    break
                }
            }
            while (true) {
                val top = maxStack.peek()
                if (maxStack.size > 1 && nums[top] < now) {
                    maxStack.pop()
                } else {
                    maxStack.push(index)
                    rightMax[index] = top
                    break
                }
            }
        }
        // ç»“æœ
        var res = 0L
        for (index in nums.indices) {
            // å¤§å€¼ç›¸åŠ 
            res += (rightMax[index] - index).toLong() * (index - leftMax[index]).toLong() * nums[index].toLong()
            // å°å€¼ç›¸å‡
            res -= (rightMin[index] - index).toLong() * (index - leftMin[index]).toLong() * nums[index].toLong()
        }
        return res
    }
}
```